# VibClip: AI Animation Platform Guide

This document serves as the **Project Overview** for AI models.

## üìö Table of Contents
- [Critical Workflow Modes](#-critical-workflow-modes)
- [Core Features](#-core-features)
- [The Hybrid Render Engine](#5-the-hybrid-render-engine)
- [Sequential Product Showcase Pattern](#-pattern-sequential-product-showcase)
- [Animation Scripting Overview](#-animation-scripting-runtime)
- [Interaction Guidelines](#-interaction-guidelines)

**üìñ Related Documentation:**
- **[Complete Animation API Reference](./animation_scripts.md)** - Full context variables and subsystems
- **[Motion System API](./motion_system.md)** - High-level cinematic components
- **[Motion Design Principles](./motion_design.md)** - Design philosophy and best practices
- **[Cinematic Recipes](./cinematic_recipes.md)** - Copy-paste code patterns

> [!IMPORTANT]
> **VibClip is a 100% JavaScript-based environment.** 
> 1. All code generated by the agent MUST be JavaScript. Execution of Python, Ruby, or other languages is NOT supported.
> 2. **NO STATIC ASSET GENERATION**: Do NOT attempt to generate image or video assets for complex objects (like phones, logos, or props). You **MUST** draw these programmatically using scripts and the `context.models` system. This ensures the engine can animate parts, change colors, and light the scene dynamically.

## üö® CRITICAL: Workflow Modes
You must adapt your behavior based on the complexity of the request.

### ‚ö° FAST MODE (Default)
**Trigger**: Simple questions, single-component tweaks, or direct "fix this" requests.
**Protocol**:
1.  **Analyze**: Briefly check the context.
2.  **Execute**: Write the code/fix immediately.
3.  **Verify**: Simple syntax check.

### üé¨ PLANNING MODE (The "Director's Workflow")
**Trigger**: Complex animations ("Create an intro..."), multi-step sequences, vague requests ("Make it pop"), or when explicitly asked to "Plan".
**Protocol (You MUST follow this order):**
1.  **üß† Imagination (Phase 0)**: Before creating a plan, you MUST act as a **Creative Director**.
    *   **Expand the Prompt**: If the user says "cool intro", you ask "Cyberpunk? Minimalist? Retro?" (self-correction).
    *   **Describe the Vibe**: Define the *lighting*, *camera movement* (slow pan, handheld shake), and *color palette* explicitly.
    *   **Narrative Arc**: What is the story? (Introduction -> Tension -> Resolution).
2.  **üìù Storyboard (Plan)**: Output a `Motion Plan` artifact defining Scenes, Timing, and Palette. **Do not write code yet.**
2.  **üß± Modular Fabrication**: Create "Scene Functions" (`playIntro`, `playScene1`) instead of one giant script.
3.  **üîó Assembly**: Combine scenes in the main loop using time-based sequencing.
4.  **‚ú® The Polish Pass**: Review your own code specifically for *feel* (easing, stagger, ambiance) and refine it.
5. **üìê Code-First Modeling**: You **MUST** build complex objects (phones, cars, UI) using `context.models.define`. 
    *   **NEVER** ask the user to upload or generate a static image for a part that needs to move or be lit.
    *   Use metallic gradients, rim lighting, and internal parts (`mod.part`).
    *   **Scene-Specific Variants**: Create specialized models for different shots (e.g., a "Macro" version for close-ups and an "Overview" version for distant shots).
6. **ü¶Ö Flight Check**: Run the **Motion Designer's Flight Check** (from `motion_design.md`) to verify quality before final handover.

---

---

## üåü Core Features

### 1. Workspace & State
- **Project-based**: Animations are saved as projects with persistent state.
- **Auto-Sync**: Changes to assets and scripts are reflected instantly in the preview.

### 2. The Asset System
- **Unified Library**: Import images and videos.

### 3. Real-Time Preview
- **Canvas-based**: Uses the standard 2D Canvas API for rendering.
- **Interactive**: Supports mouse/pointer tracking and interactive GUI controls.
- **Performance**: Optimized for 60FPS playback with GPU-accelerated frame feedback.

### 4. Export Pipelines
- **Standard (Browser)**: Native `MediaRecorder` capture.

### 5. The Hybrid Render Engine
VibClip v4.0 introduced a **Hybrid Composition Engine** that mixes automatic layout with custom JavaScript logic:
- **Auto-Render Pass**: Any visual asset (image/video) with `enabled: true` AND `visible: true` is drawn automatically before scripts run.
- **Composition Control**: Controls for `x`, `y`, `scale`, `rotation`, `fit`, `flip`, `opacity`, and `blendMode` are available for each asset.
- **Enabled vs Visible**: 
    - `enabled`: Asset is active in the project (scripts can access it).
    - `visible`: Engine automatically draws it to the canvas. Set to `false` if you want to draw it manually via code (Recommended for "Library Assets").
- **Library Assets**: If you are using images/videos solely as resources for a script (e.g., product showcased in sequence), set `visible: false` for these assets. This hides them from the auto-render pass and the timeline, keeping the project organized.
- **üö® CRITICAL: Asset Fidelity**: If a user asks to include specific images (like product screenshots), you MUST ensure they are drawn during the script. Use `context.image(assetName, ...)` with proper timing. NEVER skip requested assets.
- **Timeline Organization**: Do NOT call `add_asset_to_timeline` for these library assets. Only your main script should be on the timeline.
- **üö® CRITICAL: Global Duration Sync**: Always ensure the global animation duration is updated to match your storyboard length using `update_config({ duration: YOUR_TOTAL_SECONDS })`. 
- **Metadata Source of Truth**: Every script MUST have `const start` and `const duration` at the top. These MUST match the configuration duration if the script is the primary video director.

---

## üõçÔ∏è Pattern: Sequential Product Showcase

When a user provides multiple product images, the standard "Director Flow" is:

### üîë CRITICAL: Asset Keys Must Match Exactly

**Asset keys in your code MUST exactly match the asset names in the library.**

When you reference an asset with `context.image('assetName', ...)`, `'assetName'` must be:
- The **exact name** shown in the asset library
- **NOT** a made-up ID or random string
- **Case-sensitive** and **character-exact**

**‚ùå WRONG - Inventing fake IDs**:
```javascript
const products = [
  { id: 'abc123xyz', name: '1', title: 'Product 1' },  // 'abc123xyz' is FAKE!
  { id: 'def456uvw', name: '2', title: 'Product 2' }
];
context.image(products[0].id, ...); // ERROR: 'abc123xyz' doesn't exist!
```

**‚úÖ CORRECT - Using actual asset names**:
```javascript
// If the user uploaded assets named '1', '2', '3', '4':
const products = ['1', '2', '3', '4'];
context.image(products[0], ...); // Uses actual asset name '1'

// OR if you need metadata, reference the actual names:
const products = [
  { key: '1', title: 'Product 1' },  // 'key' matches actual asset name
  { key: '2', title: 'Product 2' }
];
context.image(products[0].key, ...); // Uses actual asset name '1'
```

**How to know asset names:** When the user uploads assets, they will have names like:
- Simple names: `'1'`, `'2'`, `'logo'`, `'background'`
- Or auto-generated: `'qljhopjlo'`, `'l3tvjdjjs'` (these ARE real asset names if provided by user)

**NEVER invent asset IDs** - always use the exact names the user provides or shows in their asset list.


1.  **Add all assets**: Keep their default names (e.g., `product1`, `product2`).
2.  **Toggle Visibility**: Set `visible: false` for all product images using `update_asset_properties`.
3.  **Modular Storyboard**:
```javascript
const start = 0;
const duration = 60;

function productSequence(time) {
  const products = ['product1', 'product2', 'product3', 'product4'];
  const segmentDuration = duration / products.length; // Dynamic based on script duration
  const index = Math.floor(time / segmentDuration) % products.length;
  const productKey = products[index];
  
  // üö® CRITICAL: Local time transitions (DO NOT use context.range here!)
  // context.range uses global time, not custom time parameters
  const localT = (time % segmentDuration) / segmentDuration;
  
  let reveal, exit;
  if (localT < 0.2) {
    // Reveal phase (0 to 0.2)
    reveal = context.ease('outBack', localT / 0.2);
    exit = 1.0;
  } else if (localT > 0.8) {
    // Exit phase (0.8 to 1.0)
    reveal = 1.0;
    exit = 1.0 - context.ease('inQuart', (localT - 0.8) / 0.2);
  } else {
    // Hold phase
    reveal = 1.0;
    exit = 1.0;
  }
  
  // Draw the current product
  context.image(productKey, context.centerX, context.centerY, 800, 800, { 
    fit: 'contain', 
    opacity: reveal * exit 
  });
}

// Main Loop
productSequence(context.time);
```


## üé® Animation Scripting (Runtime)

The core usage of VibClip is writing JavaScript code to draw on the canvas every frame.

**Key Concept**: You write the body of a function that runs 60 times a second. You have access to a rich `context` API for drawing, physics, and effects.

### üö® CRITICAL: Canvas Drawing Order

**Canvas is a painter's algorithm** - things drawn later appear **on top** of things drawn earlier.

**RULE**: Always draw in this order:
1. **Background/Environment** (fills, gradients, sky)
2. **Back-to-front content** (distant ‚Üí close objects)
3. **Foreground** (UI, text overlays, effects)

**Example:**
```javascript
// ‚úÖ CORRECT - Background drawn first
context.ctx.fillStyle = '#FFD700';
context.ctx.fillRect(0, 0, 1280, 720); // Draw background first
context.image('product', 640, 360, 800, 800); // Now image appears on top
```

### üìê Responsive Layout & Safety

**Always use relative positioning** - never hardcode pixel values:

```javascript
// ‚ùå BAD: Hardcoded size
context.image('photo', 0, 0);

// ‚úÖ GOOD: Smart Layout
context.motion.smartLayout('photo', { margin: 0.1, fit: 'contain' });

// ‚úÖ GOOD: Responsive sizing
const padding = context.width * 0.1;
const imgW = context.width - padding * 2;
context.image('photo', padding, context.centerY - 200, imgW, 400, { fit: 'contain' });
```

### ‚ö†Ô∏è Critical: Timing Utilities

**`context.range(start, end)`** - Maps global time to 0-1 within a time window:
```javascript
const opacity = context.range(0, 2); // Fade in from 0s to 2s
context.rect(100, 100, 200, 200, { fill: true, color: 'blue', opacity });
```

**`context.ease(curve, value)`** - Applies easing to normalized values:
```javascript
const t = context.range(0, 2);
const scale = context.ease('outBack', t); // Bouncy entrance
```

**For custom/local time**, use direct calculations:
```javascript
const localT = (context.time % 10) / 10; // Loop every 10s
const reveal = localT < 0.2 ? context.ease('outBack', localT / 0.2) : 1.0;
```

### üìö Complete API Documentation

This is just an overview. For the full reference including all context variables, subsystems (Camera, Physics, Timeline, FX, GUI, Color), and detailed examples:

üëâ **[Complete Animation API Reference (`animation_scripts.md`)](./animation_scripts.md)**  
üëâ **[Motion System Components (`motion_system.md`)](./motion_system.md)** - High-level helpers  
üëâ **[Motion Design Principles (`motion_design.md`)](./motion_design.md)** - Best practices  
üëâ **[Cinematic Recipes (`cinematic_recipes.md`)](./cinematic_recipes.md)** - Copy-paste patterns

---


## üîß Troubleshooting

### Common Errors & Solutions

#### "Asset not found" or Image doesn't appear
**Problem**: Asset name mismatch or asset not enabled.

**Solutions**:
1. Check exact asset name (case-sensitive): `context.assets.myImage` vs `'MyImage'`
2. Verify asset is enabled in the library
3. Check if asset exists before drawing:
```javascript
if (context.assets.logo) {
  context.image('logo', x, y, w, h);
}
```

---

#### Nothing appears on screen
**Problem**: Drawing order or visibility issues.

**Solutions**:
1. **Check drawing order** - background must be drawn first:
```javascript
// ‚úÖ CORRECT
context.ctx.fillStyle = '#000';
context.ctx.fillRect(0, 0, context.width, context.height);
context.image('photo', x, y, w, h);
```

2. **Check asset visibility** - if `visible: true`, engine auto-draws it. Set to `false` to draw manually.

3. **Check coordinates** - ensure they're within canvas bounds:
```javascript
console.log(context.width, context.height); // Check canvas size
```

---

#### Animation doesn't loop/repeat correctly
**Problem**: Time-based logic not accounting for loops.

**Solutions**:
1. Use modulo for repeating animations:
```javascript
const loopT = (context.time % 5) / 5; // Repeats every 5 seconds
```

2. For `context.range()`, it only works once. Use custom time for loops:
```javascript
// ‚ùå Won't loop
const t = context.range(0, 2);

// ‚úÖ Loops every 2 seconds
const localT = (context.time % 2) / 2;
```

---

#### "range() doesn't accept 3 parameters" error
**Problem**: Trying to pass custom time to `context.range()`.

**Solution**: `context.range()` only accepts 2 parameters and uses global `context.time`. For custom time, use direct calculations:
```javascript
// ‚ùå WRONG
const reveal = context.range(0, 0.2, localT);

// ‚úÖ CORRECT
const localT = (context.time % 10) / 10;
const reveal = localT < 0.2 ? localT / 0.2 : 1.0;
```

---

#### Performance issues / Low FPS
**Problem**: Too many draw calls or expensive operations.

**Solutions**:
1. **Reduce particle counts** - start with 50-100, not 1000+
2. **Limit blur/effects** - use `fx.bloom()` sparingly
3. **Optimize loops** - avoid nested loops over large arrays
4. **Use `context.range()`** to limit effects to specific time windows:
```javascript
// Only run expensive effect during specific time
if (context.time > 2 && context.time < 5) {
  context.fx.bloom(2.0);
}
```

---

#### Text appears cut off or wrong size
**Problem**: Hardcoded sizes don't scale with canvas.

**Solutions**:
1. Use responsive sizing:
```javascript
// ‚ùå BAD
context.text.draw('Title', 640, 360, { size: 100 });

// ‚úÖ GOOD
context.text.draw('Title', context.centerX, context.centerY, {
  size: context.minDim * 0.1  // 10% of smallest dimension
});
```

2. For text blocks, set appropriate width:
```javascript
context.text.block(longText, x, y, context.width * 0.8, { ... });
```

---

#### Colors look wrong or don't appear
**Problem**: Missing `color` property or incorrect format.

**Solutions**:
1. Always specify color in drawing options:
```javascript
// ‚ùå No color specified
context.rect(x, y, w, h, { fill: true });

// ‚úÖ Color specified
context.rect(x, y, w, h, { fill: true, color: '#3498db' });
```

2. Use valid CSS color formats:
```javascript
'#3498db'                    // Hex
'rgb(52, 152, 219)'         // RGB
'rgba(52, 152, 219, 0.5)'   // RGBA with opacity
'hsl(204, 70%, 53%)'        // HSL
```

---

#### Physics state resets every frame
**Problem**: Not using `context.physics` for persistent state.

**Solutions**:
```javascript
// ‚ùå WRONG - resets every frame
let ball = { x: 0, velocity: 0 };

// ‚úÖ CORRECT - persists between frames
if (!context.physics.ball) {
  context.physics.ball = { x: 0, velocity: 0 };
}
context.physics.ball.x += context.physics.ball.velocity * context.deltaTime;
```

---

#### Transforms affect everything after them
**Problem**: Not restoring canvas state.

**Solutions**:
1. Use `context.transform()` for automatic save/restore:
```javascript
context.transform(() => {
  context.ctx.rotate(angle);
  context.rect(0, 0, 100, 100);
}); // Automatically restored
```

2. Or manually save/restore:
```javascript
context.ctx.save();
context.ctx.rotate(angle);
context.rect(0, 0, 100, 100);
context.ctx.restore();
```

---

### Debugging Tips

1. **Use console.log()** to inspect values:
```javascript
console.log('Time:', context.time, 'Progress:', context.progress);
console.log('Asset exists:', !!context.assets.logo);
```

2. **Draw debug visualizations**:
```javascript
// Show mouse position
context.circle(context.mouse.x, context.mouse.y, 10, {
  fill: true,
  color: 'red'
});

// Show center point
context.circle(context.centerX, context.centerY, 5, {
  fill: true,
  color: 'lime'
});
```

3. **Check timing with GUI sliders**:
```javascript
const debugTime = context.gui.slider('Debug Time', 0, 10, 0);
// Use debugTime instead of context.time for testing
```

4. **Isolate the problem** - comment out sections to find what breaks:
```javascript
// context.fx.bloom(2.0); // Temporarily disabled
```

---

## üõ†Ô∏è Interaction Guidelines

### 1. Tool Chaining & Asset IDs
When you create an asset (e.g., using `add_asset_from_url`), the tool will return a `JSON` response containing the **generated ID** of the new asset.
- **ALWAYS** use the IDs returned by the tools for subsequent operations in the same turn.
- If you don't have an ID, you can try using the asset's **Name** as a fallback, as the system will attempt to resolve it.

### 2. Multi-Step Tasks
If the user asks for a complex sequence (e.g., "Grayscale then Split then Display"):
1.  **Don't assume IDs**: Call the first tool.
2.  **Read the Response**: Get the new asset IDs from the function response.
3.  **Continue**: Use those IDs in the next tool call.
4.  **Finalize**: Update assets and scripts using the final IDs.

### 3. Error Handling
- If a tool returns "Asset not found", double-check your ID or try using the name.

### 4. Explicit Timing & Timeline Sync
VibClip uses bidirectional sync between your code and the timeline. To ensure your animations are correctly represented on the timeline:
- **ALWAYS** declare `const start` and `const duration` at the top of your script.
- **NEVER** depend solely on internal logic or sequence summation for the asset's length.
- These top-level variables are the "Source of Truth" for the engine and are updated automatically when you drag blocks in the UI.

```javascript
const start = 0;
const duration = 10; // Explicitly define the length of this script

// Your animation logic here...
```
