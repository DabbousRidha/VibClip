import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get current directory in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Navigate up from scripts/ to root
const VE_ROOT = path.resolve(__dirname, '..');
const DOCS_DIR = path.join(VE_ROOT, 'docs');
const TARGET_FILE = path.join(VE_ROOT, 'src/agent/systemPrompt.ts');

/**
 * Escapes content for safe inclusion in a TypeScript template literal.
 * 
 * Logic:
 * 1. Backslashes (\) must be escaped to (\\) so they appear as literal backslashes in the generated string.
 * 2. Backticks (`) must be escaped to (\`) so they don't terminate the template literal.
 * 3. Template placeholders (${) must be escaped to (\${) so they aren't interpolated during assignment.
 */
function escapeContent(content) {
    return content
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$\{/g, '\\${');
}

function generateSystemPrompt() {
    console.log('üîÑ Starting System Prompt Generation...');

    if (!fs.existsSync(DOCS_DIR)) {
        console.error(`‚ùå Error: Docs directory not found at ${DOCS_DIR}`);
        process.exit(1);
    }

    // Find all markdown files
    const files = fs.readdirSync(DOCS_DIR).filter(f => f.endsWith('.md'));

    if (files.length === 0) {
        console.warn('‚ö†Ô∏è  Warning: No markdown files found in docs directory.');
    } else {
        console.log(`üìÇ Found ${files.length} documentation files:`, files.join(', '));
    }

    const docs = {};

    // Read and process files
    files.forEach(file => {
        const filePath = path.join(DOCS_DIR, file);
        const rawContent = fs.readFileSync(filePath, 'utf8');

        // Generate a variable name from the filename (e.g., "ai.md" -> "AI_GUIDE")
        const baseName = file.replace(/\.md$/i, '').toUpperCase().replace(/[^A-Z0-9]/g, '_');
        const variableName = `${baseName}_DOC`;

        docs[variableName] = {
            filename: file,
            variableName: variableName,
            content: escapeContent(rawContent)
        };
    });

    // Construct the file content
    let fileContent = `/**
 * @file systemPrompt.ts
 * @description Auto-generated system prompt including all documentation from /docs
 * @generated ${new Date().toISOString()}
 * 
 * ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY.
 * Run 'node scripts/update_system_prompt.js' to regenerate.
 */

`;

    // 1. Output the constants
    Object.values(docs).forEach(doc => {
        fileContent += `const ${doc.variableName} = \`
${doc.content}
\`;

`;
    });

    // 2. Build the injection sections
    const docInjections = Object.values(docs).map(doc => {
        return `
// --- Source: docs/${doc.filename} ---
\${${doc.variableName}}
`;
    }).join('\n---\n');

    // 3. Define the main export
    fileContent += `export const VE_SYSTEM_PROMPT = \`
You are VibClip Assistant, an expert **Motion Design Director** and orchestrator for the VibClip Animation Engine.
Your goal is to transform text into cinematic storytelling, prioritizing motion design, visual flow, and high production value.

**STRICT LANGUAGE CONSTRAINT:**
- You **ONLY** speak and write code in **JavaScript**.
- **NEVER** use Python, Ruby, or any other language for animation scripts or tool calls.
- Transition directly to writing JavaScript code for the VibClip Engine.

**CORE DIRECTIVES:**
1. **üß† IMAGINATION FIRST**: Before writing code, you MUST "imagine" the scene. Output a **<Thinking>** block where you describe the *lighting*, *mood*, *camera movement*, and *narrative arc*.
2. **Director Persona**: Don't just execute the prompt. If the user says "make it cool", you must fill in the blanks with specific creative choices (e.g., "I will use a Cyberpunk aesthetic with neon blue grid and glitch text").
3. **Consult The Cookbook**: ALWAYS check the **Cinematic Recipes (cinematic_recipes.md)** for patterns.
4. **Motion Quality**:
   - üö´ **NEVER** use \\\`linear\\\` easing for primary motion.
   - üåä **FLOW**: Use staggered entries.
5. **Asset Fidelity & Sync**:
   - üíé **NEVER** omit requested assets.
   - üïí **DURATION SYNC**: Always sync global duration.

**ACTION PROTOCOL:**
- **STEP 1: IMAGINE**: Start your response with a <Thinking> block describing your creative plan.
- **STEP 2: EXECUTE**: Use \\\`create_script\\\` or \\\`update_script_content\\\`.
- If you are creating a new animation, you MUST call \\\`create_script\\\` as your first action.
- Think in **Scenes** (using 'context.timeline.sequence'), not static slides.

CURRENT CONTEXT:
The user is working in a browser environment.
The following documentation outlines the API, features, and guidelines for the platform.



---
${docInjections}
---

\`;
`;

    // Write to disk
    try {
        // Ensure directory exists
        const dir = path.dirname(TARGET_FILE);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(TARGET_FILE, fileContent);
        console.log(`‚úÖ Successfully updated: ${TARGET_FILE}`);
        console.log(`   Size: ${(fileContent.length / 1024).toFixed(2)} KB`);
    } catch (err) {
        console.error('‚ùå Failed to write file:', err);
        process.exit(1);
    }
}

generateSystemPrompt();
